# 大小字节序理解和鉴定系统字节序方法

最近遇到大小字节序问题和网络传输时的字节序问题，给大家整理一下，希望大家对字节序有个比较深入的了解，其实理解了就很简单的。  

开始遇到的问题：  
1. 本地的数据通过网络传输然后在目的地解析网络上的数据，字节序是如何统一的  
2. 字节序不同，数据（如0xFF00）存入内存地址中位置不同（大字节序：FF--低地址位   00--高地址位  ；小字节序： 00--低地址位  FF--高地址位），为什么读出的值都是0xFF00  

下面让我们带着问题来理解：  

大字节序：大端有效 ，高位数据先放入低地址内存  ， 低位数据再放入高地址内存  
小字节序：小端有效，低位数据先放入低地址内存 ， 高位数据再放入高地址内存  
注意：描述的是将数据（肉眼看到的）放入内存中的地址（计算机的内存中）  

__举一个例子__  
数字`0x12 34 56 78`在内存中的表示形式为：  
1)大端模式：  
```
低地址 ------------------> 高地址  
0x12  |  0x34  |  0x56  |  0x78
```  
2)小端模式：  
```
低地址 ------------------> 高地址
0x78  |  0x56  |  0x34  |  0x12
```  
可见，大端模式和字符串的存储模式类似。  

3)下面是两个具体例子：  
16bit宽的数0x1234在Little-endian模式（以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：  
```
内存地址     小端模式存放内容	大端模式存放内容  
0x4000      0x34	        0x12  
0x4001	    0x12	        0x34
```  
32bit宽的数0x12345678在Little-endian模式以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：  
```
内存地址	小端模式存放内容    大端模式存放内容  
0x4000	   0x78	            0x12  
0x4001	   0x56	            0x34  
0x4002	   0x34	            0x56  
0x4003	   0x12	            0x78
```  
4)大端小端没有谁优谁劣，各自优势便是对方劣势：  
小端模式 ：计算机电路先处理低位字节，效率比较高; 强制转换数据不需要调整字节内容。  
大端模式 ：人类读写习惯; 符号位的判定固定为第一个字节，容易判断正负。  

__数组在大端小端情况下的存储：__  
以unsigned int value = 0xFFEEBBAA为例，分别看看在两种字节序下其存储情况，我们可以用unsigned char buf[4]来表示value：
```
Big-Endian: 低地址存放高位，如下：
高地址
        ---------------
        buf[3] (0xAA) -- 低位
        buf[2] (0xBB)
        buf[1] (0xEE)
        buf[0] (0xFF) -- 高位
        ---------------
        低地址
Little-Endian: 低地址存放低位，如下：
高地址
        ---------------
        buf[3] (0xFF) -- 高位
        buf[2] (0xEE)
        buf[1] (0xBB)
        buf[0] (0xAA) -- 低位
        --------------
低地址
```  

然后看一下图示吧：
![](https://github.com/MulticsYin/MulticsDevOps/blob/master/picture/site00.png)

相信大家对遇到的第二个问题已经知道答案了吧，现在再来看看第一个问题。  
网络字节序：是大字节序，在把数据进行网络传输时，要保证自己传输到网络上的数据时大字节序。  

再来看看图示吧：  
![](https://github.com/MulticsYin/MulticsDevOps/blob/master/picture/site01.png)

1号线路：发数据和接收数据都不需要转序，因为自己是和网络都是大字节序  
2号线路：发数据和接收数据都需要转序，因为自己是小字节序，网络都是大字节序，才能保证自己本系统的数据永远都是小字节序。可能高级语言（java、C#屏蔽了字节序，大家感受不到，那是因为高级语言内存进行封装和处理了）  

鉴定大小字节序的C语言程序
```c
#include <stdlib.h>
#include <string.h>

union {
    int     i;
    char    ch;
}data;

int main() {
    /*将结合体的整型值赋值为1，如果是小字节序，小端有效，低地址写入的就是1，读出字符ch就是1 
      如果是大字节序，大端有效，低地址写入的就是0，读出字符ch就是0*/
    data.i = 1;
    if(data.ch) {
        printf("this system is  small-endian\n");
    } else {
        printf("this system is  big-endian\n");
    } 
    return 0;
}
```

原因：  
将结合体的整型值赋值为1，如果是小字节序，小端有效，低地址写入的就是1，读出字符ch就是1  
如果是大字节序，大端有效，低地址写入的就是0，读出字符ch就是0  

参考：  
* [大小字节序的深入理解和鉴定系统字节序方法](http://www.cnblogs.com/dxx-blogs/p/5324320.html)  
* [详解大端模式和小端模式](http://blog.csdn.net/ce123_zhouwei/article/details/6971544)
* [理解字节序](http://www.ruanyifeng.com/blog/2016/11/byte-order.html)
* [字符编码笔记：ASCII，Unicode 和 UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)

## [返回目录](https://github.com/MulticsYin/MulticsDevOps#网络编程)
